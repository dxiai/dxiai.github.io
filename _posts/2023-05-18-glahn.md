--- 
layout: post
title: R-Vektoren ohne Schleifen
date: 2023-05-18
author: Christian Glahn
tags: 
- funktionale Programmierung
- R
- Map-Reduce
- Style
- No Loops
---

Bei [R-Bloggers](https://www.r-bloggers.com/) bin ich heute auf den [Beitrag von Steven Sanderson II](https://www.spsanderson.com/steveondata/posts/rtip-2023-05-17/index.html) gestossen, welcher die Funktion `strftime()` erkl√§rt. Ich habe den Artikel eigentlich nur gelesen, um festzustellen, was die R-Community gerade so besch√§ftigt. Weil der gezeigte Code auf mich geradezu antiquiert wirkte, musste ich das Datum des Beitrags kontrollieren und habe festgestellt, dass der Beitrag erst einen Tag alt war üò±.

Hier ist der anst√∂ssige Code aus dem Originalbeitrag: 

```R
RightNow <- Sys.time()

# all of the modifiers
for (formatter in sort(c(letters, LETTERS))) {
  modifier <- paste0("%", formatter)
  print(
    paste0(
      modifier, 
      " used on: ",
      RightNow,
      " will give: ",
      strftime(RightNow, modifier)
    )
  )
}
```

Das verwendete Programmierparadigma ist **imperativ**, was nicht mehr ganz zu modernem R passt. Ich habe mich gefragt, wie aufw√§ndig eine L√∂sung im **funktionalen** Programmierparadigma ausfallen w√ºrde, um den sprachlichen Eigenschaften von modernen R-Versionen gerechtzuwerden. Weil der Code im Originalbeitrag ohne zus√§tzliche Bibliotheken auskommt, musste die funktionale L√∂sung ebenfalls in Base R umgesetzt werden.

Hier ist meine L√∂sung: 

```R
c(letters, LETTERS) |> 
    sort() |>
    (\(formatter) paste0("%", formatter))() |> 
    (\(modifier, RightNow) paste0(
        modifier, 
        " used on: ", 
        RightNow, 
        " will give: ", 
        strftime(RightNow, modifier)
    ))(Sys.time())
```

Diese L√∂sung kommt ohne globale Variablen und Schleifen aus und ist ausserdem kompakter als die urspr√ºngliche Variante. 

Meine L√∂sung verwendet den *native Pipe*-Operator (`|>`) sowie die Kurzform f√ºr anonyme Funktionsdeklarationen (`\()`). Beide Operatoren sind seit zwei Jahren bzw. seit [Version 4.1.0 Teil von Base R](https://cran.r-project.org/bin/windows/base/old/4.1.0/NEWS.R-4.1.0.html) und geh√∂ren somit zum sprachlichen Kern von R.

Der Anfang des Codes ist bis zum Aufruf von `sort()` identisch mit der Logik des urspr√ºnglichen Codes: Das Ergebnis ist ein Vektor mit der sortierten Kombination der beiden Basis-Vektoren `letters` und `LETTERS`. Ab diesem Punkt spare ich mir die `for`-Schleife und nutze aus, dass R-Funktionen immer f√ºr alle Elemente eines Vektors als implizite [Map-Funktion](https://de.wikipedia.org/wiki/MapReduce) ausgef√ºhrt werden.

Die Code-Zeile `(\(formatter) paste0("%", formatter))()` erstellt eine anonyme Hilfsfunktion, welche vor jeden √ºbergebenen Parameterwert ein Prozentzeichen einf√ºgt, und f√ºhrt diese Funktion sofort aus. Diese Hilfsfunktion wird nur deshalb ben√∂tigt, weil der Pipe-Operator die Werte ausschliesslich als ersten Parameter an die nachfolgende Funktion √ºbergeben kann. Die Funktion `paste0()` kann aber die √ºbergebenen Zeichenketten nur in dieser Reihenfolge aneinanderf√ºgen. Die Hilfsfunktion l√∂st dieses Problem, indem die Funktion den Datenfluss der Pipe aufnimmt und dann f√ºr die Funktion `paste0()` korrekt arrangiert. 

Damit die Hilfsfunktion sofort ausgef√ºhrt werden kann, muss die Funktionsdeklaration geklammert werden. Dieser Klammer folgen dann die Funktionsparameter. In diesem Fall steht f√ºr die Parameterliste nur `()`, weil der einzige Parameter von der Pipe eine Zeile dar√ºber weitergereicht und deshalb nicht angegeben wird.

Das letzte Fragment erstellt die Ausgabezeichenkette und ist ebenfalls als anonyme Hilfsfunktion umgesetzt. Diesmal hat die Funktion zwei Parameter, weil f√ºr die Ausgabe zwei Werte von Bedeutung sind. Der erste Parameter `modifier` wird von der Pipe bef√ºllt und erh√§lt so den Ergebnisvektor der ersten Hilfsfunktion. Der zweite Parameter `RightNow` nimmt das Ergebnis der Funktion `Sys.time()` auf. Weil diese Parameter√ºbergabe nur ***eine*** Ausf√ºhrung dieser Funktion erfordert, entf√§llt die globale Variable `RightNow` des urspr√ºnglichen Codes und die damit verbundenen potenziellen Seiteneffekte. 

Die beiden Hilfsfunktionen haben einen positiven Nebeneffekt: Die Variablennamen der urspr√ºnglichen L√∂sung bleiben f√ºr die Lesbarkeit erhalten.

Weil die Lesbarkeit durch die Kurzform der Funktionsdeklaration und die vielen Zeilenumbr√ºche f√ºr die Ausgabe leidet, hier noch eine Variante in der funktionalen Langform: 

```R
c(letters, LETTERS) |> 
    sort() |>
    (function (formatter) paste0("%", formatter))() |> 
    (function (modifier, RightNow) paste0(
        modifier, " used on: ", RightNow, " will give: ", strftime(RightNow, modifier)
    ))(Sys.time())
```

Das sieht doch gleich viel besser aus. üòé

F√ºr die Funktionsweise dieser Logik empfielt sich die Lekt√ºre des [Beitrags von Steven Sanderson II](https://www.spsanderson.com/steveondata/posts/rtip-2023-05-17/index.html).

**-- EDIT 22. Mai 2023 --**

Ich wurde gefragt, wie eine [`tidyverse`-L√∂sung](https://www.tidyverse.org) aussehen w√ºrde. Meine L√∂sung orientiert sich wieder an der urspr√ºnglichen L√∂sung und verwendet keine zwischengeschalteten komplexen Objekte.

Die einfachste L√∂sung ist die naive Umsetzung meiner Schlussl√∂sung.

```R
c(letters, LETTERS) %>% 
    sort() %>%
    str_c("%", .) %>% 
    (function (modifier, RightNow) str_c(
        modifier, " used on: ", RightNow, " will give: ", strftime(RightNow, modifier)
    ))(Sys.time())
```

In der tidyverse-Philosophie ist ein explizites `map()` aber vorzuziehen. Also hier die `purrr`-Variante mit `map()`:

```R
library(tidyverse)

c(letters, LETTERS) %>% 
    sort() %>%
    str_c("%", .) %>% 
    map(function(modifier, RightNow) 
            str_c(modifier, " used on: ", RightNow, " will give: ", strftime(RightNow, modifier)),
        Sys.time())
```

Die Alternative mit einem Dataframe/tibble w√§re komplexer und gibt das Ergebnis als Tabelle und nicht als Liste von Zeichenketten aus. Deshalb w√§re das im Sinne der √úbung keine richtige L√∂sung. Zur Vollst√§ndigkeit aber trotzdem:

```R
library(tidyverse)

tibble(modifier = c(letters, LETTERS)) %>%
    arrange(modifier, .locale = "en") %>%
    mutate(
        modifier = str_c("%", modifier),
        RightNow = Sys.time(),
        result = strftime(RightNow, modifier)
    ) %>%
    rename(
        "with timestamp"= RightNow,
        "will give" = result
    )
```
